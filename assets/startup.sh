#!/bin/sh
set -eu

## Script will be run as chrony user !

DEFAULT_NTP="0.pool.ntp.org,1.pool.ntp.org,2.pool.ntp.org,3.pool.ntp.org"
CHRONY_CONF_FILE="/etc/chrony/chrony.conf"

CURRENT_USER="$(id -u)"
CURRENT_GROUP="$(id -g)"
CURRENT_USERGROUP="$CURRENT_USER:$CURRENT_GROUP"
CHRONY_USERGROUP="$(id -u chrony):$(id -g chrony)"

echo "
-------------------------------------
ℹ️ Container Information
-------------------------------------
OS:            $(. /etc/os-release; echo "${PRETTY_NAME}")
Docker user:   $(whoami)
Docker uid:    $CURRENT_USER
Docker gid:    $CURRENT_GROUP
"

if [ "$CURRENT_USERGROUP" != "$CHRONY_USERGROUP" ]; then
  echo "[WARNING] Container running under a different user than recommended!"
  echo ""
fi

# Check if existing volumes/folders are writable
if [ ! -w "/etc/chrony" ] || [ ! -w "/run/chrony" ] || [ ! -w "/var/lib/chrony" ]; then
  echo "
It seems that the necessary folders are not writable by the container user ($CURRENT_USERGROUP).
As this container is running as non-root, it cannot fix the permissions it self.

Please remove the volumes or update them to be writable by $CURRENT_USERGROUP.
Or run the container with 'user: \"0:0\"' so it will ran as root so it can fix itself.

If using tmpfs update the config to:
tmpfs:
  - /etc/chrony:rw,mode=1750,uid=$CURRENT_USER,gid=$CURRENT_GROUP
  - /run/chrony:rw,mode=1750,uid=$CURRENT_USER,gid=$CURRENT_GROUP
  - /var/lib/chrony:rw,mode=1750,uid=$CURRENT_USER,gid=$CURRENT_GROUP
"
  exit 1
fi

# confirm correct permissions on chrony run directory
if [ -d /run/chrony ]; then
  chown -R chrony:chrony /run/chrony
  chmod o-rx /run/chrony
  # remove previous pid file if it exist
  rm -f /var/run/chrony/chronyd.pid
fi

# confirm correct permissions on chrony variable state directory
if [ -d /var/lib/chrony ]; then
  chown -R chrony:chrony /var/lib/chrony
fi

## dynamically populate chrony config file.
{
  echo "# https://github.com/simonrupf/docker-chrony"
  echo
  echo "# chrony.conf file generated by startup script"
  echo "# located at $0"
  echo
  echo "# time servers provided by NTP_SERVER environment variables."
} > ${CHRONY_CONF_FILE}


# NTP_SERVERS environment variable is not present, so populate with default server
if [ -z "${NTP_SERVERS:-}" ]; then
  NTP_SERVERS="${DEFAULT_NTP}"
fi

# LOG_LEVEL environment variable is not present, so populate with chrony default (0)
# chrony log levels: 0 (informational), 1 (warning), 2 (non-fatal error) and 3 (fatal error)
if [ -z "${LOG_LEVEL:-}" ]; then
  LOG_LEVEL=0
else
  # confirm log level is between 0-3, since these are the only log levels supported
  if expr "${LOG_LEVEL}" : "[^0123]" > /dev/null; then
    # level outside of supported range, let's set to default (0)
    LOG_LEVEL=0
  fi
fi

IFS=","
for N in $NTP_SERVERS; do
  # strip any quotes found before or after ntp server
  N_CLEANED=$(printf "%s" "$N" | tr -d '"')

  # check if ntp server has a 127.0.0.0/8 address (RFC3330) indicating it's
  # the local system clock
  if echo "${N_CLEANED}" | grep -q '^127\.'; then
    echo "server ${N_CLEANED}" >> ${CHRONY_CONF_FILE}
    echo "local stratum 10"    >> ${CHRONY_CONF_FILE}

  # found external time servers
  else
    if [ "${ENABLE_NTS:-false}" = true ]; then
      echo "server ${N_CLEANED} iburst nts" >> ${CHRONY_CONF_FILE}
    else
      echo "server ${N_CLEANED} iburst" >> ${CHRONY_CONF_FILE}
    fi
  fi
done

# PTP0 configuration: if it has been passed through, it means we want to use it
if [ -e /dev/ptp0 ]; then
  echo "refclock PHC /dev/ptp0 poll 3 dpoll -2 stratum 2" >> ${CHRONY_CONF_FILE}
fi

# final bits for the config file
{
  echo
  echo "driftfile /var/lib/chrony/chrony.drift"
  echo "makestep 0.1 3"
  if [ -n "${NTP_DIRECTIVES}" ]; then
    echo -e "${NTP_DIRECTIVES}"
  fi
  if [ "${NOCLIENTLOG:-false}" = true ]; then
    echo "noclientlog"
  fi
  echo
  echo "allow all"
} >> ${CHRONY_CONF_FILE}

# enable control of system clock, disabled by default
SYSCLK="-x"
if [ "${ENABLE_SYSCLK:-false}" = true ]; then
  SYSCLK=""
fi

## startup chronyd in the foreground
exec /usr/sbin/chronyd -U -u chrony -d ${SYSCLK} -L ${LOG_LEVEL}
